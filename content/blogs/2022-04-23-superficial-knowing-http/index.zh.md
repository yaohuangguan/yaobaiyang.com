---
title: 小小地记录下HTTP的理解
kind: post
description: >-
  Well, just some thoughts on http and it's model...
date: '2021-09-25T02:38:31.953Z'
categories:
  - engineering
keywords:
  - http
  - network
  - protocol
published: true
cover: ./toa-heftiba-1399721-unsplash-optimized.jpg
coverAuthor: Toa Heftiba
coverOriginalUrl: https://unsplash.com/photos/_2HNqkk6FEU?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText
---

### HTTP请求模型

#### 两个端

一个客户端

凡是主动发起请求的就是客户端

一个服务端

返回相应的就是服务端，不能主动连接客户端

#### 两个动作

一个请求 一个相应

![](https://docimg9.docs.qq.com/image/bRm_wREQtw-ou_QKz6zNEA.png?w=1082&h=358)

  

### 无状态协议

cookie + session 配合才能维持住会话

web socket 也是http协议，然后协议升级

网络拓扑结构 -> 网络中的节点设备是如何布局的

  

### 大概流程

![](https://docimg3.docs.qq.com/image/Wk4miHkn4dkyF740wjS8Jw.png?w=1272&h=804)

1.  用户要在浏览器访问 url
    
2.  浏览器要先检查防火墙/网关/代理这一步，是否能连通网络？
    
3.  访问服务器要通过ip，但是需要把url转成ip，所以要访问DNS服务器，域名和ip的映射关系。ipv4 无符号的整型，四个字节，一个字节对应一段，取值范围0-255
    
4.  要经过很多个路由器才能到达目标服务器
    
5.  浏览器到达一个机房，机房里有很多服务器，这个ip是这个机房的出入口，通过反向代理服务器转发，到了具体服务器
    
6.  服务器收到了请求，开始干活，把东西准备好了之后，把数据给浏览器
    
7.  数据通过链路再过来
    
8.  浏览器内部处理，浏览器内部渲染，html转成DOM，处理css，js，图片排版合成，交给显卡处理，然后呈现给用户
    
9.  END
    

  

历史：最早的互联网是美国军方的，阿帕网，用于去中心化的设备联通。美国和苏联冷战的时候，核战争威胁，为了防止通信中枢被打掉，发明一种去中心化的通信方式。比如两端，连多个数据线，冗余备份。通信网是大中心，大中心挂小中心，小中心挂微型中心，在通信节点上放很多路由器，路由器之间是网状连接的。如果把其中一个路由器打掉了，网状结构还是有其他通路可以到达。家用路由器是小儿科，真正的路由器应该是很大很贵的。

  

#### 如何追踪链路上的路由器？

```
$: traceroute www.baidu.com

```

用的是icmp数据报协议

如果有的路由器是 *，那么就是该路由器是不允许ping他的。

  

#### 路由策略

数据包怎么知道该走哪条路？路由器里有路由表，有主用的，有下一跳（跳转）的位置。

  

#### ping的协议

##### icmp_seq

ping的包的编号，ping是icmp协议，数据报协议。

##### ttl

从你的电脑到目标服务器中间隔了多少个路由器，比如 ttl=48，那么就是unix/linux的协议实现的ttl默认值是64（windows是128），每经过一个路由器，路由器会把包里的ttl -1, 所以是经过了 64 -48 =16个路由器。如果ttl减到0，就会把包丢到，不再继续传了。

为了防止数据包在路由器中无限制的传输，如果路由器配的有问题，形成环了，永远到不了目的地，数据包会无限的传。会造成路由器崩溃，扛不住一直处理无效的数据包。

  

### 什么是HTTP

http1,http2,http3

![](https://docimg2.docs.qq.com/image/b04eY4lDk3pg2AOP_It1Sg.png?w=1150&h=268)

  

http1.0 短连接，每发一次数据，tcp都要重新建立

http 1.1 支持了长链接，对tcp链路的复用，请求一个网页，css，js，图片，不反复的连接断开tcp了，同一个链路直到没有后续数据了，才断开tcp

http3 使用udp协议，为了解决链路效率问题

HTTP默认端口号 80， HTTPS 默认端口号 443

  

#### 工作过程

一次HTTP操作称为一个事务，把很多个小的操作当成一个操作，叫原子操作。就是说如果这些步骤中有出错的，会把之前的操作全部回滚，回到初始状态。

1.  首先客户端和服务器需要建立连接
    
2.  建立tcp连接之后，客户端发一个请求给服务器，格式为：统一资源标识符(uri)，协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容
    
3.  服务器收到请求后，返回响应信息，格式为一个状态行包括着协议版本号，成功或失败的状态码，MIME信息包括服务器信息、实体信息等
    
4.  客户端接收相应展示在浏览器中，断开连接
    

以上描述是http1.0短连接，如果是长链接那么就是第2，3步重复，直到没有数据请求之后，断开连接。

  

#### 请求

![](https://docimg6.docs.qq.com/image/iuQrMklv5NReZC9M6xRUQg.png?w=1082&h=572)

![](https://docimg2.docs.qq.com/image/3zqOQu2lzj4Z0Unz0pSREw.png?w=744&h=268)

报文行和报文体之间并不空，里面有回车符（0x0D）/r 和换行符（0x0A）/n

里面是ASCII编码，一个字符对应一个编号，有可见字符和不可见字符（控制字符）

##### ASCII 编码 -- 回车和换行

ASCII是古老的字符，是从英文打字机来的。

![](https://docimg9.docs.qq.com/image/9ffsa6kN3dCaYfV2J52bLw.png?w=700&h=525)

当按下按键的时候，中间部分是铅字，会把铅字抬起来敲到色带上，然后打到纸上。纸卷在滚筒上，滚筒随着敲键盘的时候移动，打完一行了卷纸的滚筒到头了，滚筒到头了应该归位，重新打下一行。这个回来的操作叫做 回车。回车了还不行，还得滚一行，叫做 换行。

所以在设计HTTP协议的时候，要加回车和换行符。但现在在windows/linux系统设计中，只有换行符

  

邮局 -> 电报网 -> 电话网 -> 互联网

为什么古罗马的马屁股的宽度能决定美国火箭的直径？

马屁股的宽度决定了马车车辙的宽度，车辙的标准沿用了两千年，直到了第一次工业革命，有了火车，火车的窄轨铁路的宽度就是车辙的宽度，一开始马车拉着车跑，后来有了蒸汽机。美国火箭太大，得用铁轨用，仍然是窄轨铁路的规范。后来做的发射火箭的平台，运输到火箭的发射平台。

  

#### 响应

![](https://docimg3.docs.qq.com/image/ewsDZj9J9fVI9pOe-fElxQ.png?w=1258&h=614)

  

#### 请求方法

GET 请求获取 uri 所标识的资源

POST 在 uri 所表示的资源后附加新的数据

HEAD 请求获取由 uri 所标识的资源响应消息报头，不完整的GET，不返回响应体

PUT 请求服务器存储一个资源，并用 uri 作为标识

DELETE 请求服务器删除 uri 所标识的资源

TRACE 请求服务器回送收到的请求，主要用于测试或诊断，相当于基本协议的 ECHO

CONNECT HTTP1.1协议预留给能将连接改为管道方式的代理服务器，比如HTTP代理

OPTIONS 请求查询服务器性能，或支持方法等，比如MongoDB web服务，专门用OPTIONS去获取db的性能参数

  

#### 请求报头

##### Accept

告诉服务器，客户端接受什么格式的数据，几乎所有格式，比如image/webp格式，webp是google定的规则，其他浏览器不支持，加入服务器没有根据Accept里面的返回了对应的格式，那么就可能显示不了

##### Accept-Encoding

是否支持数据压缩，http1.1文本格式，不够紧凑占空间比较大，消耗网络带宽，为了节省消耗所以进行压缩

##### Accept-Language

类似于Accept，但是表达的是接受的语言用自然语言来分类，比如zh-cn，us-en

##### Authorization

客户端请求服务器的时候，服务器判断此字段是否有权限查看资源，没有的话则返回401

##### Connection

是不是长链接，keep-alive

##### Cookie

在请求时候是在一个字段里的，在响应时候，cookie是一个一个回来

##### Host

服务器域名

##### User-Agent

告诉服务器，客户端环境的基本情况

##### Referer

源头，当前请求的上一个请求的资源是什么，用来防盗链，反爬虫。现在爬虫套路越来越深，现在反爬虫都是服务端去探测，用机器学习、大数据发现请求过于密集或者和其他用户行为不一致，在判断是爬虫

  

#### 响应报头

##### Connection

服务端支持长链接，keep-alive

##### Content-Encoding

客户端发送了压缩的请求，服务端支持压缩的方式，如果要解码Content-Type中的媒体类型，必须要使用响应的解压缩方式

##### Content-Type

内容的类型，返回的内容

##### Date

缓存策略，已过时。

##### Expires

缓存策略，给出响应过期的日期和时间

##### Last-Modified

用于指示资源的最后修改日期和时间

##### Server

是哪一个服务器种类，此报头和请求中的User-Agent是对应的

##### Set-Cookie

设置cookie

##### Location

重定向到一个新的位置，通常在更换域名的时候

##### Cache-Control

协商缓存

  

#### 状态码

三位数字组成，且有五种可能取值

1xx 指示信息 用在异步处理上面，表示请求已接收，继续处理，因为HTTP有超时限制，长时间客户端会重发，所以返回1xx。比如协议升级，表明有后续的工作去做

2xx 成功

3xx 重定向 资源变位置了，或者服务器重定向到另个地址

4xx 服务器认为客户端有问题，资源不存在，权限不足等

5xx 服务端错误，未能实现合法的请求

  

#### Cookie 与 Session

为了解决HTTP无状态的问题，解决客户端无状态的问题

服务器得知道客户端是谁，在过去的时候，计算机固定的，IP也是固定的，服务器通过IP来维持会话。现在是移动网就不行了

每次HTTP请求完成，TCP就断了，服务器的协议栈不保存IP，状态保存不住。依赖Cookie和Session来保持状态

Cookie存在于浏览器，Session存在于服务器

  

##### Cookie是哪里生成的

服务端生成的，事实上浏览器也可以生成Cookie

浏览器提供的API，有createCookie,意味着客户端也可以生成

一般情况，是服务端下发的Cookie

服务端下发多个Cookie，通过Set-Cookie

Cookie有五个属性，name，生效的路径path，生效的时间expire，是给浏览器生效还是app生效

如果客户端第一请求没带cookie，服务端认为是第一次来，会签发一个cookie，然后第二次或第N次客户端再次请求会带上返回的cookie，就相同于门禁卡，有卡才能进，没过期才能进。

Cookie一般用在会话登录，某些不良公司，某度，会在Cookie里加很多cookie，为了识别你，追踪你，通过大数据去碰，推送一下广告

  

#### HTTP缓存机制

缓存就是提高性能，减少IO(IO特点，速度慢，容易形成性能瓶颈)开销，减少输入输出开销，输入输出是针对CPU来说的

网络就是IO，跨硬件通信

缓存在IO外面，如果有缓存直接走缓存的内容，不再去IO

##### 优点

对于请求是静态资源，不会经常变动，比如html，图片，logo等

但如果是SSR，html是服务端渲染，经常发生变动，就不该缓存

对客户端而言，减少相应延迟

网络带宽对服务器是极其宝贵的资源，减少网络带宽的消耗，省钱

  

##### 缓存策略与机制

![](https://docimg3.docs.qq.com/image/tG6Kdxu99cQ-ehu8EouKVA.png?w=752&h=614)

第一次请求本地没有缓存，由服务器决定缓存策略，由服务器配置，这个步骤叫 缓存协商

Cache-Control 协商缓存

  

第二次到第N次，优先找强制缓存策略，本地是否有缓存

![](https://docimg3.docs.qq.com/image/eP7OqhJNDRmcZEKHyjkx4A.png?w=808&h=770)

如果没有强制缓存，那么保鲜期(Expires)就是请求的时间

走右边的分支就有两个对比缓存的策略，对比现在的资源和原来的资源是不是同一个。客户端得把文件的特征发给服务器，服务器依靠文件的指纹MD5，还依靠文件的生成的时间戳。文件的指纹更可靠，时间戳是可以改的。比如linux中的touch 命令，如果touch index.js 不存在会创建，如果文件已经存在就修改文件的时间戳。

Etag的优先级更高，文件的指纹是否改变，因为更可靠，如果没有Etag策略就只能时间戳策略了

###### 对比策略 Etag

服务端会返回Etag字段，浏览器在请求头带上If-None-Match字段，md5的值。服务器收到MD5检查文件的md5是否一致，如果一致会返回304，304本地跳转，浏览器收到304会直接从浏览器读缓存。如果发生了变化，就要重推返回200状态码，新的资源也要写上缓存

*避免空中碰撞*

比如编辑在线文档时候，服务端将当前的文档内容被打成md5的值通过Etag头字段返回给客户端，

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4

```

当客户端保存文档的时候，会POST请求给服务端，并包含Etag值的If-Match字段

```
If-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

```

如果服务端判断哈希值不匹配，则代表文档已经不是最新的，已经被修改，那么就会返回412代表 Precondition Failed 前提条件失败错误。

  

###### 对比策略 Last-Modified

服务端返回Last-Modified字段，浏览器在下次请求时会带上If-Modified-Since字段里面是之前返回的时间戳。在Etag策略失效的时候，才检查此策略。和Etag流程一样，不一样的就是这个是检查时间戳

  

###### 强制缓存

在一段时间之内，不重复去服务器请求，用缓存。缓存时间过了，执行对比缓存策略，过期了重新拉取数据，没过期时间再延长，这个时间叫 保鲜时间(Expires)

###### 对比缓存

Etag/If-None-Match 策略

根据文件的md5去检查文件有没有变化

Last-Modified/If-Modified-Since 策略

根据文件的时间戳去检查

  

  

### TCP/IP 协议栈

![](https://docimg6.docs.qq.com/image/MF7XYLHlnBR-QhKUP_6BOA.png?w=856&h=666)

#### 应用层

app直接去用的那一层，HTTP协议，DNS, SSH , FTP，SMTP协议，程序可以直接调用的协议

如果是ISO表示的规定，应用层分为应用层，表示层，会话层，层次简单

#### 传输层

TCP, UDP协议

#### 网络层

底层协议，支撑传输层

ping 命令，icmp原始数据报协议

连到局域网（DHCP协议服务探查）

ip地址是否冲突，ARP协议

#### 数据链路层

硬件：数据传给网线的网络端口或调制解调器

软件：串口协议 slip协议

#### 物理层

硬件的东西，网线电缆，电话线，无线电，wifi，5G，光缆，电缆